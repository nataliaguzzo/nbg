<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Natália Brambatti GUZZO - Research</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NEVK03VJ8F"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NEVK03VJ8F', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Natália Brambatti GUZZO</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./research.html" aria-current="page"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-talian" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Talian</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-talian">    
        <li>
    <a class="dropdown-item" href="./talian.html">
 <span class="dropdown-text">Talian</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./language.html">
 <span class="dropdown-text">Language</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./corpus.html">
 <span class="dropdown-text">Corpus</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Research</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<meta name="description" content="I'm a linguist who does research in phonology, phonology-syntax interface, language contact, language variation, and language acquisition."><meta name="robots" content="index, follow"><section id="ongoing-and-past-projects" class="level3">
<h3 class="anchored" data-anchor-id="ongoing-and-past-projects">Ongoing and past projects</h3>
<section id="phonological-representations" class="level4">
<h4 class="anchored" data-anchor-id="phonological-representations"><strong>1. Phonological representations</strong></h4>
<p><img src="figures/bebi.jpeg" class="main-figure img-fluid" title="Penelope being cute">Most of my research focuses on how speakers build phonological representations, based on evidence from natural language grammars, experiments, phonetic data and corpus data. For example, in both collaborative and sole-authored work, I have investigated the effect of prosodic factors on the manifestation of rhotics in Brazilian Veneto, the patters of metaphony in Brazilian Veneto, the relationship between vowel reduction and phonological structure in Brazilian Portuguese, and the structural conditioning of high vowel deletion in Québec French. <!-- I have investigated whether prosodic constituents can be identified based on indirect phonological evidence or subtle phonological phenomena, and whether prosodic constituency constrains (subtle) phonological variation. Recently, I have examined the realization of rhotic sounds in Brazilian Veneto (Talian), a language that has a single rhotic phoneme that seems to be manifested differently depending on position and stress. With <a href="https://guilhermegarcia.github.io" target="_blank">Guilherme Garcia</a>, I have examined vowel reduction in neoclassical elements in Brazilian Portuguese as a way to determine their prosodic representation. With <a href="http://people.linguistics.mcgill.ca/~heather.goad/" target="_blank">Heather Goad</a> and Guilherme Garcia, I have probed whether foot structure in Québec French can be identified on the basis of weakening segmental processes such as variable high vowel deletion.  --></p>
<p><em>Output:</em></p>
<ul>
<li><p><strong>Guzzo, Natália Brambatti</strong>. submitted. Plural alternations and consonant syllabification in Brazilian Veneto.</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong>. accepted. Prosodically-conditioned variation: Rhotics in Brazilian Veneto. In Rajiv Rao (Ed.). <em>The phonetics and phonology of heritage languages</em>. Cambridge: CUP.</p></li>
<li><p>Garcia, Guilherme D. and <strong>Natália Brambatti Guzzo</strong>. 2023. A corpus-based approach to map target vowel asymmetry in Brazilian Veneto metaphony. <em>Italian Journal of Linguistics</em> 35(1): 115–138.</p></li>
<li><p>Garcia, Guilherme D. and <strong>Natália Brambatti Guzzo</strong>. 2022. Lexical access in Portuguese stress. <em>Journal of Portuguese Linguistics</em> 21(7): 1–24. [<a href="https://doi.org/10.16995/jpl.8188">paper</a>]</p></li>
<li><p>Goad, Heather and <strong>Natália Brambatti Guzzo</strong>. 2022. Regularly inflected forms can be prosodically ambiguous in English. <em>Proceedings of the 2021 Annual Conference of the Canadian Linguistic Association</em>.</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong> and Guilherme D. Garcia. 2021 Gradience in prosodic representation: vowel reduction and neoclassical elements in Brazilian Portuguese. <em>Glossa: a journal of general linguistics</em> 6(1): 74. 1–26. [<a href="https://doi.%20org/10.5334/gjgl.1413">paper</a>]</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong>, Heather Goad and Guilherme D. Garcia. 2018. What motivates high vowel deletion in Québec French: Foot structure or tonal profile? <em>Proceedings of the 92nd Annual Meeting of the Linguistic Society of America</em>. [<a href="https://doi.org/10.3765/plsa.v3i1.4306">paper</a>]</p></li>
<li><p>Garcia, Guilherme D., Heather Goad and <strong>Natália Brambatti Guzzo</strong>. 2017. Footing is not always about stress: Formalizing variable high vowel deletion in Québec French. <em>Proceedings of 2016 Annual Meeting on Phonology (AMP)</em>. [<a href="http://dx.doi.org/10.3765/amp.v4i0.3991">paper</a>]</p></li>
<li><p>Garcia, Guilherme D., Heather Goad and <strong>Natália Brambatti Guzzo</strong>. 2017. L2 acquisition of high vowel deletion in Québec French. <em>Proceedings of the 41st Boston University Conference on Language Development (BUCLD)</em>. [<a href="http://www.lingref.com/bucld/41/BUCLD41-22.pdf">paper</a>]</p></li>
</ul>
</section>
<section id="the-acquisition-of-phonological-representations" class="level4">
<h4 class="anchored" data-anchor-id="the-acquisition-of-phonological-representations"><strong>2. The acquisition of phonological representations</strong></h4>
<p>I have examined the development of phonological representations in monolingual and bilingual acquisition. I have investigated the acquisition of affricates relative to the acquisition of branching onsets in Québec French (where affricates are in complementary distribution with coronal stops). In collaborative work, I have examined whether children acquiring two languages with distinct representations for word-level stress (such as French and English) are able to differentiate between the two systems. <!-- under the hypothesis that the constraints regulating the distribution of affricates are onerous for children, resulting in affricates being acquired after branching onsets.   --></p>
<p><em>Output:</em></p>
<ul>
<li><p><strong>Guzzo, Natália Brambatti</strong>. 2022. Revisiting the acquisition of onset complexity: Affrication in Québec French. <em>Journal of Child Language</em> 49: 774–798. [<a href="https://doi.org/10.1017/S0305000921000374">paper</a>]</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong>, Heather Goad and Megan Deegan. 2020. Phonological systems in conflict: The acquisition of stress in bilingual French and English. <em>Proceedings of the 55th Meeting of the Chicago Linguistic Society 2019</em>.</p></li>
</ul>
</section>
<section id="phonological-representations-in-a-situation-of-language-contact" class="level4">
<h4 class="anchored" data-anchor-id="phonological-representations-in-a-situation-of-language-contact"><strong>3. Phonological representations in a situation of language contact</strong></h4>
<p>I have also investigated how language contact affects speakers’ phonological representations. My focus is on Portuguese-Veneto contact in a region of southern Brazil known as the Italian Immigration Area (IIA). I have also worked on a description of the Brazilian Veneto (Talian) phonological/phonetic system. <strong>See more about this project <a href="talian.html">here</a>.</strong></p>
<p><em>Output:</em></p>
<ul>
<li><p><strong>Guzzo, Natália Brambatti</strong>. 2022. Brazilian Veneto (Talian). <em>Journal of the International Phonetic Association – Illustrations of the IPA</em>. [<a href="https://doi.org/10.1017/S002510032200010X">paper</a>]</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong> and Guilherme D. Garcia. 2020. Phonological variation and prosodic representation: Clitics in Portuguese-Veneto contact. <em>Journal of Language Contact</em> 13(2): 389-427. [<a href="https://doi.org/10.1163/19552629-bja10021">paper</a>]</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong>. 2018. Language contact determines prosodic representation and variation. 92nd Annual Meeting of the Linguistic Society of America (LSA), Salt Lake City (UT), USA, Jan 4-8. [<a href="materials/lsa2018.pdf">poster</a>]</p></li>
</ul>
</section>
<section id="effects-of-prosody-on-sentence-interpretation" class="level4">
<h4 class="anchored" data-anchor-id="effects-of-prosody-on-sentence-interpretation"><strong>4. Effects of prosody on sentence interpretation</strong></h4>
<p><img src="figures/dengo.jpeg" class="main-figure img-fluid" title="Peggy being cute">In both joint and single-authored research, I have investigated how prosodic cues (such as pauses, changes in pitch, stress, and constituent size) impact native speakers’ and second language learners’ interpretations of ambiguous sentences. I have so far worked on ambiguous sentences involving depictive predicates in Brazilian Portuguese, relative clauses in English, and anaphoric pronouns in Italian.</p>
<p><em>Output:</em></p>
<ul>
<li><p><strong>Guzzo, Natália</strong> and Chau Tran. in prep. The use of prosodic cues in the interpretation of ambiguous relative clauses in English by Vietnamese speakers.</p></li>
<li><p>White, Lydia, Heather Goad, Liz Smeets, Guilherme D. Garcia, <strong>Natália Brambatti Guzzo</strong>, and Jiajia Su. accepted. Pronoun interpretation in L2 Italian: Exploring the effects of prosody. <em>Linguistic Approaches to Bilingualism</em>.</p></li>
<li><p>Goad, Heather, <strong>Natália Brambatti Guzzo</strong> and Lydia White. 2021. Parsing ambiguous relative clauses in L2 English: Learner sensitivity to prosodic cues. <em>Studies in Second Language Acquisition</em> 43: 83–108. [<a href="https://doi.org/10.1017/S0272263120000285">paper</a>]</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong> and Heather Goad. 2017. Overriding default interpretations through prosody: Depictive predicates in Brazilian Portuguese. <em>Proceedings of the 91st Annual Meeting of the Linguistic Society of America</em>. [<a href="http://dx.doi.org/10.3765/plsa.v2i0.4077">paper</a>]</p></li>
<li><p>White, Lydia, Heather Goad, Jiajia Su, Liz Smeets, Marzieh Mortazavinia, Guilherme D. Garcia and <strong>Natália Brambatti Guzzo</strong>. 2017. Prosodic effects on pronoun interpretation in Italian. <em>Proceedings of the 41st Boston University Conference on Language Development (BUCLD)</em>. [<a href="http://www.lingref.com/bucld/41/BUCLD41-60.pdf">paper</a>]</p></li>
</ul>
</section>
<section id="prosodic-organization" class="level4">
<h4 class="anchored" data-anchor-id="prosodic-organization"><strong>5. Prosodic organization</strong></h4>
<p>In research stemming from my dissertation, I have examined how clitics and compounds in Brazilian Portuguese (BP) are mapped into prosodic domains. The phonological behaviour of certain clitics and compounds in BP supports two assumptions about prosodic structure which had previously been considered as mutually exclusive: (a) the idea that there is a specific prosodic domain for the representation of composite structures (the composite group; Vogel, 2009), and (b) the idea that prosodic domains can be recursive (e.g., Inkelas, 1990; Selkirk, 1996).</p>
<p><em>Output:</em></p>
<ul>
<li><p><strong>Guzzo, Natália Brambatti</strong>. 2018. The prosodic representation of composite structures in Brazilian Portuguese. <em>Journal of Linguistics</em> 54(4): 683–720. [<a href="http://dx.doi.org/10.1017/S0022226718000099">paper</a>]</p></li>
<li><p><strong>Guzzo, Natália Brambatti</strong>. 2017. Recursion in Brazilian Portuguese complex compounds. In Ruth Lopes, Juanito Ornelas de Avelar and Sonia Cyrino (Eds.) <em>Romance Languages and Linguistic Theory 12. Selected papers from the 45th Linguistic Symposium on Romance Languages (LSRL)</em>, pp.&nbsp;97–110. Amsterdam: John Benjamins. [<a href="https://benjamins.com/catalog/rllt.12">link</a>]</p></li>
</ul>
</section>
<section id="l2heritage-language-acquisition-of-syntax" class="level4">
<h4 class="anchored" data-anchor-id="l2heritage-language-acquisition-of-syntax"><strong>6. L2/heritage language acquisition of syntax</strong></h4>
<p>I have also investigated some topics in L2/heritage language syntax.</p>
<p><em>Output:</em></p>
<ul>
<li><p><strong>Guzzo, Natália Brambatti</strong> and Avery Franken. in prep. Structure preservation and contact effects: Subjects in Brazilian Veneto.</p></li>
<li><p>Xia, Vera Yunxiao, Lydia White and <strong>Natália Brambatti Guzzo</strong>. 2022. Intervention in relative clauses: Effects of relativized minimality on L2 representation and processing. <em>Second Language Research</em> 38(2): 347–372. [<a href="https://doi.org/10.1177/0267658320958742">paper</a>]</p></li>
<li><p>Slabakova, Roumyana, Lydia White and <strong>Natália Brambatti Guzzo</strong>. 2017. Pronoun interpretation in the second language: Effects of computational complexity. <em>Frontiers in Psychology</em> 8: 1–12. [<a href="https://doi.org/10.3389/fpsyg.2017.01236">paper</a>]</p></li>
</ul>
<hr>
<p>See <a href="https://nataliaguzzo.github.io/cv/guzzo-cv.pdf">my CV</a> for a list of all my publications.</p>
<hr>


</section>
</section>

<p style="text-align: center">
Copyright © 2024 Natália Brambatti Guzzo
</p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>